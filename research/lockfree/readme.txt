
1. method_insert_handles() is the main function to add additional optimizations to each class method at the end of synchronize_method().

Inside method_insert_handles(), basic code templates (e.g., ReadWrapper_Handle for accessing objects modified via logs) are added to places where optimizations can be applied. These basic handles are later replaced with code templates for specific optimizations such as CheckConflict_Handle for conflict detection etc.

method_insert_handles() is used to optimize each shared class method at the end of synchronize_method().

2. synchronize_constructor_destructor() and synchronize_recursive_functions are similar to method_insert_handles(). They are called at the end of make_shared() to transform constructor/destructor and recursive functions. Particularly, when fixing ABA problem, types of some class members are changed, thus access to these members need be changed correspondingly. Also since a recursive function can be called by both write method and read method, two different versions using different conflict detection policies are generated.

3. fix_ABA_problem() is used to fix ABA problem, particularly to change the types of class members.

4. Some global variables are introduced for the convenience of optimizations. These global variables are introduced because:
(1) some information needed by the optimization stage is generated by previous stages long ago which is very inconvenient to be passed via returns etc.
(2) some tables are needed to record scope-dependent information.

Here are global variables used for optimization.
<<* syn1: memopt + fixaba
<<* syn4: memopt
<<* syn5: noopt
<define syn_name NULL/>

<<* members of modify logs;
<<* obtained inside xform.gen_modify_log();
<<* used for generating garbage_collector etc;
<define modlog_members NULL/>

<<* type of shared objects modified via logs;
<<* obtained inside xform.gen_modify_log();
<<* used for handling conflict detection and ABA prevention etc;
<define logvar_type NULL />

<<* used for generating temp variables to store the return of check_conflict
<define tmp_var_idx 0/>

<<* tables to find shared object and the tempory variable storing its value
<<* to avoid repeated conflict detection
<define var2tmpvar MAP{}/>
<define tmpvar2val MAP{}/>

<<* if a variable is locally defined, it doesn't need to be handled
<define local_defvar MAP{}/>

<<* record recursive functions
<define recursive_functions MAP{}/>



