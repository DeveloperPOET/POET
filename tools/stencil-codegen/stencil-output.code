include Cfront.code

<* max of n1 or n2 *>
<xform max pars=(n1, n2)>
 res = n2;
 if(n1 > n2) {
    res = n1;
 }

 res
</xform>

<* helper for getting the timestep max *>
<xform tmax pars=(to)>
  res = max(2, to+1)
</xform>


<* get index or limit variable name for a given dimension  *>
<xform get_index_var pars=(which_dim) limit=0>
  res = "i"^which_dim;
  if(limit) res = "N"^which_dim;
  res
</xform>


<* Essentially a map between index t and the corresponding name (0 = tnew, 1 = tm1, etc)*>
<xform get_timestep_varname pars=(t)>
  res = "tnew";
  if(t > 0) res = "tm"^t;
  res
</xform>

<* Get the timestep number index for the corresponding timestep*>
<xform get_timestep_value pars=(to, tvar, t, tidx)>
  tcount = tmax(to);
  res = "("tidx"+("tcount"-1)) % "tcount;
  if(t > 0) res = "("tidx"+("tcount"-1-"t")) % "tcount;
  res
</xform>

<* Include division (or via multiplicative inversion) on an operation *>
<xform add_div pars=(div, divvar, on_oper, mi) decl=0>
  res = "";

  if(div) {
    if(decl) {
      
      decl_builder =Bop#("+",FunctionCall#("floor",FunctionCall#("fmod", (FunctionCall#("rand",NULL) 1))), 2);
      if(mi) decl_builder = Bop#("/", 1, decl_builder);

      res = DeclStmt#(TypeInfo#(FloatType#"double", divvar, VarInit#(CastExp#(FloatType#"double",decl_builder))));
    } else {
      op = "/";
      if(mi) op = "*";
      res = on_oper;
      for(nd = 0; nd < div; nd = nd+1) {
        res = Bop#(op, "("res")", divvar);
      }
    }
  } else {
    res = on_oper;
  }
  res
</xform>


<* Create variables for timestep indices *>
<xform gen_stencil_timestep_indices pars=(to, tidx) decl_only=0>
  res = "";
  val_builder = "";
  for(t = 0; t < tmax(to); t=t+1) {
    tvar = get_timestep_varname(t);
    if(decl_only) {
      val_builder = val_builder :: DeclStmt#(TypeInfo#(IntType#"long", tvar, ""));
    } else {
      val_builder = val_builder :: ExpStmt#(Assign#(tvar, get_timestep_value(to, tvar, t,tidx)));
    }
  }
  if(decl_only == 0)
    res = StmtList#(val_builder);
  else
    res = val_builder;
  res
</xform>

<* generate stencil body *>
<xform gen_stencil_init pars=(arrayvar, test_arrayvar, coefvar, dim, oa, to, coeftype)>
  access_builder = "";

  for(t = 0; t < tmax(to); t=t+1) {
    arr_builder = ArrayAccess#(arrayvar, t);
    test_arr_builder = ArrayAccess#(test_arrayvar, t);
    for(id = 0; id < dim; id=id+1) {
        arr_builder = ArrayAccess#(arr_builder, get_index_var(id));
        test_arr_builder = ArrayAccess#(test_arr_builder, get_index_var(id));
    }

    internal_builder = ExpStmt#(Assign#(arr_builder, "rand()"));

    ifdef_builder = "#ifdef VALIDATE";
    test_arr_builder = ExpStmt#(Assign#(test_arr_builder, arr_builder));
    endif_builder = "#endif";
    test_arr_builder = ifdef_builder :: test_arr_builder :: endif_builder;

    access_builder = access_builder :: internal_builder :: test_arr_builder;
  }

  if(coeftype == 1) {
    <* Need to initialize variable coefficients *>
    ncoefs = dim*oa+1;
    coefiter = "l";

    for(l = 0; l < ncoefs; l=l+1) {
      coef_builder = ArrayAccess#(coefvar, coefiter);
      for(id = 0; id < dim; id=id+1) {
        coef_builder = ArrayAccess#(coef_builder, get_index_var(id));
      }

      coef_builder = ExpStmt#(Assign#(coef_builder, CastExp#(FloatType#"double",FunctionCall#("fmod", (CastExp#(FloatType#"double","rand()") 2)))));
    }

    res=StmtList#(access_builder Nest#(Loop#(coefiter,0,dim*oa+1,1), coef_builder));
  } else {
    res = access_builder;
  }

  res
</xform>

<* generate stencil body *>
<xform gen_stencil_compare pars=(arrayvar1, arrayvar2, dim, oa, to, coeftype)>
  access_builder = "";

  lhs_builder = ArrayAccess#(arrayvar1, "tlast");
  rhs_builder = ArrayAccess#(arrayvar2, "tlast");
  for(id = 0; id < dim; id=id+1) {
      lhs_builder = ArrayAccess#(lhs_builder, get_index_var(id));
      rhs_builder = ArrayAccess#(rhs_builder, get_index_var(id));
  }


  cond_builder = Bop#("!=", lhs_builder, rhs_builder);
  body_builder = ExpStmt#(FunctionCall#("fprintf", ("stderr", "\"Comparison Failed at index %d (%lf!=%lf)\\n\"",get_index_var(0), lhs_builder, rhs_builder)));
  err_builder = ExpStmt#(FunctionCall#("exit",("EXIT_FAILURE") ));

  checker = Nest#(If#(cond_builder), body_builder :: err_builder);

  access_builder = access_builder :: checker;

  res = access_builder;

  res
</xform>

<* Get coefficient to weigh a point *>
<xform get_coefficient pars=(dim, d, order, oa, oa_i, coeftype) temporal=0>
  res = "";
  depth = (oa * order)/4;
  oa_shifted = oa_i + depth;
  coef_weights = NULL;
  ncoefs = "";

   if(coeftype == 0) {
    <* Constant coefficients, isotropic discretization *>
    if(temporal) {
      oa_shifted = oa_i; 
  
      <*For temporal orders, the first coef will always be ignored (it's the new timestep)*>
      if(order == 1) {
        coef_weights = ("-1", "1");
        ncoefs = 2;
      } else if(order == 2) {
        coef_weights = ("-1", "2", "-1");
        ncoefs = 3;
      }
    } else {
      ncoefs = depth*2 + 1;
      if(oa == 2) {
        coef_weights = ("1","-2","1");
      } else if(oa == 4) {
        <* reps ("-1/12", "4/3", "-5/2", "4/3", "-1/12") *>
        coef_weights = ("-0.083", "1.33", "-2.5", "1.33", "-0.083");
      }
    }

    for(i = 0; i < LEN(coef_weights); i=i+1) {
      if(i == oa_shifted) {
        weight = coef_weights[i];
        res = weight;
        BREAK;
      }
    }
  } else if(coeftype == 1) {
    <* Variable coefs, anisotropic discretization *>
    if(temporal) {
      <*not supported*>
    } else {
      dim_idx = 0;
      if(oa_i < 0) {
        <* we are left of center, use absolute value *>
        dim_idx = -oa_i;
      } else if(oa_i > 0) {
        dim_idx = oa_i + depth; 
      }

      val = 0;
      if(dim_idx != 0) {
        val = (d-1)*(depth*2) + dim_idx
      }

      vaccess = ArrayAccess#("c", val);
      for(i = 0; i < dim; i = i+1) {
        vaccess = ArrayAccess#(vaccess, get_index_var(i));
      }
      res = vaccess;
    }
  }

  res
</xform>


<* create access for a specific term, considering coefficient type and place.
  ivar of 0 is temporal, 1 is x, 2 is y, 3 is z
  Put ivars in ascending order
*>
<xform gen_neighbor_stencil_access pars=(arrayvar, dim, order, oa, to, coeftype, ivars_list, div, divvar, mi)>
  access_builder = "";
  depth = (oa*order)/4;
  center_used = 0;

  first = 1;
  for(ivars_iter = ivars_list; ivars_iter != NULL; ivars_iter = TAIL(ivars_iter)) {
    ivars = HEAD(ivars_iter);

    if(HEAD(ivars) > dim) {
      <* derivative is for a dimension we don't have set *>
      CONTINUE;
    }

    timesteps_to_consider = 1;
    if(HEAD(ivars) == 0) {
      <* This derivative is mixed *>
      timesteps_to_consider = tmax(to);
    }

    for(t = 1; t <= timesteps_to_consider; t=t+1) {
      ivar_builder = "";

      <* Spatial derivatives: 
        starts at 1 for spatial comparisons, where x is 1*>
      for(oa_i = -depth; oa_i <= depth; oa_i=oa_i+1) {

        loc = ArrayAccess#(arrayvar, get_timestep_varname(t));

        if(oa_i == 0 && coeftype == 1) {

          <* Only use the center point once when using variable coefficients *>
          if(center_used == 0) {
            center_used = 1;
          } else {
            CONTINUE;
          }
        }
        for(d = 1; d <= dim; d=d+1) {

          deriv_here = 0;

          <* go through each dimension at each depth and see who needs to be brought in *>
          for(ivars_i = ivars; ivars_i != NULL; ivars_i = TAIL(ivars_i)) {
            ivar = HEAD(ivars_i);
            if(ivar == d) {
              <*We take a derivative WRT this dim*> 
              deriv_here = 1;
            }
          }
          if(deriv_here) {
            loc = ArrayAccess#(loc, get_index_var(d-1)+oa_i)
          } else {
            loc = ArrayAccess#(loc, get_index_var(d-1))
          }
        }

        c = get_coefficient(dim,HEAD(ivars), order, oa, oa_i, coeftype);

        if(first) {
          first = 0;
          access_builder = Bop#("*", c, loc);
        } else {
          access_builder = Bop#("+", access_builder, Bop#("*",c, loc));
        }
      }
    }
  }

  if(div) access_builder = add_div(div, divvar, access_builder, mi);

  <* temporal *>
  if(to >= 1) {
    for(t = 1; t < tmax(to); t=t+1) {
      loc = ArrayAccess#(arrayvar, get_timestep_varname(t));
      for(d = 0; d < dim; d=d+1) {
        loc = ArrayAccess#(loc, get_index_var(d));  
      }
      loc = Bop#("*", loc, get_coefficient[temporal=1](dim,NULL,to, 2, t, 0));
      access_builder = Bop#("+",access_builder,loc);
    }
  }

  <* build the array access to write into *>
  tvar = get_timestep_varname(0);
  tnew_builder = ArrayAccess#(arrayvar,tvar);
  for(d = 0; d < dim; d=d+1) {
    tnew_builder = ArrayAccess#(tnew_builder, get_index_var(d));
  }


  res = ExpStmt#(Assign#(tnew_builder, access_builder))
</xform>

<* generate various code from stencil dimension *>
<xform gen_stencil_dim pars=(dim) macro=0 size=0 index=0 bc_size=1 body="" >
 res=(body=="")? NULL : body;
 for (i = dim-1; i >= 0; i=i-1) {
   if (body != "") {
       res=Nest#(Loop#(get_index_var(i),bc_size,get_index_var[limit=1](i)-bc_size,1), res);
   }
   else if (size > 0) {
      var = "N"^i;
      if (macro != 0) var = MacroDef#(var, 100);
      res = var :: res;
   }
   else if (index > 0) { var = get_index_var(i); res = var :: res; }
   else { "" = "Error: nothing is generated"; }
 }
res
</xform>

<* generate subscript reference with dim sizes and index variable *>
<xform gen_stencil_subscript pars=(size, index) >
  res = 0;
  for (p = index; p != NULL; p = cdr(p)) {
    size=cdr(size);
    res = res + Multiply#((car p):: size);
  }
  res
</xform>

<* generate stencil body *>
<xform gen_stencil_stmt pars=(old_array, new_array, dim, points)>
 sizes = gen_stencil_dim[size=1](dim);
 index = gen_stencil_dim[index=1](dim);
 cur_pos = gen_stencil_subscript(sizes, index);
 rhs = ArrayAccess#(old_array,cur_pos); 
 p_index=index; cur_pts = 1;
 for (i = 0; i < dim; i=i+1) {
   cur_index = REPLACE((car(p_index)), (car(p_index))+1, index);
   rhs = rhs + ArrayAccess#(old_array, gen_stencil_subscript(sizes,cur_index));
   cur_index = REPLACE((car(p_index)), (car(p_index))-1, index);
   rhs = rhs + ArrayAccess#(old_array, gen_stencil_subscript(sizes,cur_index));
 }
 res = ExpStmt#(Assign#(ArrayAccess#(new_array,cur_pos), rhs / points));
</xform>


<* generate the code to declare the stencil arrays *>
<xform gen_stencil_arrays pars=(arr_name, dim, oa, to, elemtype,coeftype)>
  size_builder = "";
  decl_builder = "";
  for(i = 0; i < dim; i=i+1) {
    if(i == 0) {
      decl_builder = ArrayDim#(get_index_var[limit=1](i));
      size_builder = Bop#("*", get_index_var[limit=1](i), SizeOf#(SizeOfArg#(FloatType#"double","")));

    } else {
      decl_builder = decl_builder :: ArrayDim#(get_index_var[limit=1](i));
      size_builder = Bop#("*", get_index_var[limit=1](i), size_builder);
    }
  }
  
  res = DeclStmt#((TypeInfo#(ArrayType#(FloatType#"double",(decl_builder)),FunctionPtr#arr_name, VarInit#(CastExp#(PtrType#(FloatType#"double"),FunctionCall#("malloc",Bop#("*",max((to+1),2), size_builder)))))));

  coefs = NULL;
  if(coeftype == 1) {
    <* anisotropic, variable coefficients *>
    ncoefs = (oa*dim) + 1;
    res = StmtList#(res :: DeclStmt#((TypeInfo#(ArrayType#(FloatType#"double",(decl_builder)),FunctionPtr#"c", VarInit#(CastExp#(PtrType#(FloatType#"double"),FunctionCall#("malloc",Bop#("*",ncoefs, size_builder))))))));
  }

  res
</xform>

<xform get_problem_size pars=(ts, dim)>
  res = "";

  for(d = 0; d < dim; d=d+1) {
    if(d == 0) {
      res = get_index_var[limit=1](d);
    } else {
      res = res^", "^ get_index_var[limit=1](d);
    }
  }
  for(d = dim; d < 3; d=d+1) {
    res = res^", 0";
  }

  res
</xform>

<xform do_free pars=(varname, depends_on)> 
  res = "";
  if(depends_on) {
    res = ExpStmt#(FunctionCall#("free", varname));
  }
  res
</xform>

<code stencil_main pars=(elem, dim, oa, to, div, mi, coeftype, time, points )>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <math.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <stencil_config.h>

double GetWallTime(void)
   {
      struct timeval tp;
      static long start=0, startu;
      if (!start)
      {
         gettimeofday(&tp, NULL);
         start = tp.tv_sec;
         startu = tp.tv_usec;
         return(0.0);
      }
      gettimeofday(&tp, NULL);
      return( ((double) (tp.tv_sec - start)) + (tp.tv_usec-startu)/1000000.0 );
   }

#ifndef RANDSEED
#define RANDSEED 1
#endif

int main(int argc, char ** argv) 
{
  if (argc != 5) {
    printf ("Wrong number of parameters.\n", argv[0]);
    exit (-1);
  }

  long N0 = atoi (argv[1]); 
  long N1 = atoi (argv[2]);
  long N2 = atoi (argv[3]);
  long TS = atoi (argv[4]);

  @gen_stencil_arrays("u",dim,oa,to,elem,coeftype)@;
#ifdef VALIDATE
  long tlast = 0;
  @gen_stencil_arrays("u_test",dim,oa,to,elem,coeftype)@;
#endif
  
  long @ExpList#(gen_stencil_dim[index=1](dim))@,i,t,l;
  @gen_stencil_timestep_indices[decl_only=1](to,"")@ 

  @add_div[decl=1](div, "divvar", NULL, mi)@

  srand(RANDSEED);

  @gen_stencil_dim[bc_size=0;body=gen_stencil_init("u", "u_test", "c", dim, oa, to, coeftype)](dim)@

  benchInit();
  benchBeginStencil();

#pragma scop
  for (t = 0; t < TS; t++) {
    @gen_stencil_timestep_indices(to,"t")@ 

    @gen_stencil_dim[bc_size=(oa/2);body=gen_neighbor_stencil_access("u",dim, 2,oa,to,coeftype, ((1 1) (2 2) (3 3)), div, "divvar", mi) ](dim)@
  }
#pragma endscop

  benchEndStencil();
  benchSetEnv();
  benchSetDomain(@dim@,@oa@,@to@);
  benchSetProblemSize(@get_problem_size(time,dim)@, TS);
  benchSetArithProps(@((dim*oa)+1+to-1)@, 0, @((dim*oa)+1+to+(mi*div))@, @(div-(mi*div))@);
  benchSetMemProps(@((dim-1)*oa+1+to+(coeftype*((dim*oa)+1)))@, 1);
  benchSetMatProps(@coeftype@, 1); //Fix for (long distance mats, immediate mats)
  benchSetFpSize(sizeof(double));
  benchFinalize();


#ifdef VALIDATE
  for (t = 0; t < TS; t++) {
    @gen_stencil_timestep_indices(to,"t")@ 

    @gen_stencil_dim[bc_size=(oa/2);body=gen_neighbor_stencil_access("u_test",dim, 2,oa,to,coeftype, ((1 1) (2 2) (3 3)), div, "divvar", mi) ](dim)@

    tlast = tnew;
  }

  @gen_stencil_dim[bc_size=0;body=gen_stencil_compare("u", "u_test", dim, oa, to, coeftype)](dim)@
  @do_free("u_test", 1)@
#endif

  @do_free("u", 1)@
  @do_free("c", coeftype)@

  return EXIT_SUCCESS;
}

</code>
